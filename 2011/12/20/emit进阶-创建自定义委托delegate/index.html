<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  
  <title>Emit进阶 创建自定义委托Delegate | Kiminozo&#39;s Tech Blog</title>
  <meta name="author" content="kiminozo">
  
  <meta name="description" content="关注Windows phone开发">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

  <meta property="og:title" content="Emit进阶 创建自定义委托Delegate"/>
  <meta property="og:site_name" content="Kiminozo&#39;s Tech Blog"/>

  <link rel="alternate" href="/atom.xml" title="Kiminozo&#39;s Tech Blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="icon" type="image/x-icon" href="/favicon.ico">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
  
</head>


<body>
  <div class="wrapper">
    <header id="header"><div class="title">
  <h1><a href="/">Kiminozo&#39;s Tech Blog</a></h1>
  <p><a href="/"></a></p>
</div>
<nav class="nav">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
    <div class="content"><article class="post">
  <header>
    
      <div class="icon"></div>
      <time datetime="2011-12-19T23:04:00.000Z"><a href="/2011/12/20/emit进阶-创建自定义委托delegate/">12月 20 2011</a></time>
    
    
  
    <h1 class="title">Emit进阶 创建自定义委托Delegate</h1>
  

  </header>
  
  <div class="entry">
    
      <p>随着上次对Emit的研究，对MSIL和Emit有了进一步了解，不过为了更好地实现Aop需要自己定义委托，但是Emit定义委托就没有类这么容易理解，在多次对照IL代码后，终于成功的实现了自定义委托Delegate。</p>
<p>首先来看看一般的委托定义方法。</p>
<div class="cnblogs_code"><br><pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">delegate</span> <span style="color: #0000ff;">string</span> MyDelegate(<span style="color: #0000ff;">string</span> message);</pre><br></div>

<p>MSDN定义，委托是一种数据结构，它引用静态方法或引用类实例及该类的实例方法。</p>
<p>但是委托的本质是一个由系统自动生成的类，我们首先看看IL里面的MyDelegate的结构</p>
<p><img src="http://pic002.cnblogs.com/images/2011/25121/2011122014442844.jpg" alt=""></p>
<p>可以看到实际上MyDelegate是继承自MulticastDelegate的类</p>
<p>MSIL表示方式如下：</p>
<div class="cnblogs_code"><br><pre><span style="color: #0000ff;">.class</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">auto</span> <span style="color: #0000ff;">ansi</span> sealed EmitDemo.DelegateDemo.MyDelegate<br>       <span style="color: #0000ff;">extends</span> [mscorlib]System.MulticastDelegate<br>{<br>} <span style="color: #008000;">//</span><span style="color: #008000;"> end of class EmitDemo.DelegateDemo.MyDelegate</span><span style="color: #008000;"><br></span><br><br><span style="color: #0000ff;">.method</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">hidebysig</span> <span style="color: #0000ff;">specialname</span> <span style="color: #0000ff;">rtspecialname</span><br>        <span style="color: #0000ff;">instance</span> <span style="color: #0000ff;">void</span>  .ctor(<span style="color: #0000ff;">object</span> <span style="color: #800000;">‘</span><span style="color: #800000;">object</span><span style="color: #800000;">‘</span>,<br>                             <span style="color: #0000ff;">native</span> int <span style="color: #800000;">‘</span><span style="color: #800000;">method</span><span style="color: #800000;">‘</span>) runtime <span style="color: #0000ff;">managed</span><br>{<br>} <span style="color: #008000;">//</span><span style="color: #008000;"> end of method MyDelegate::.ctor</span><span style="color: #008000;"><br></span><br><span style="color: #0000ff;">.method</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">hidebysig</span> newslot <span style="color: #0000ff;">virtual</span><br>        <span style="color: #0000ff;">instance</span> <span style="color: #0000ff;">string</span>  Invoke(<span style="color: #0000ff;">string</span> message) runtime <span style="color: #0000ff;">managed</span><br>{<br>} <span style="color: #008000;">//</span><span style="color: #008000;"> end of method MyDelegate::Invoke</span></pre><br></div>

<p>&nbsp;</p>
<p>不考虑异步调用，实际的类大概是这样的表示形式，但是C#并不允许直接继承MulticastDelegate，所以编译是无法通过的。</p>
<div class="cnblogs_code"><br><pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> MyDelegate:MulticastDelegate<br>    {<br>        <span style="color: #0000ff;">public</span> MyDelegate(<span style="color: #0000ff;">object</span> target,IntPtr method)<br>            :<span style="color: #0000ff;">base</span>(target,method)<br>        {<br><br>        }<br><br>        <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">override</span> <span style="color: #0000ff;">string</span> Invoke(<span style="color: #0000ff;">string</span> message){}<br>    }</pre><br></div>

<p>接下来仿照这个定义来实现委托类</p>
<p>首先是moduleBuilder 经常使用Emit的应该很熟悉了</p>
<div class="cnblogs_code"><br><pre>           <span style="color: #0000ff;">string</span> name = <span style="color: #800000;">“</span><span style="color: #800000;">MyDelegateDemo</span><span style="color: #800000;">“</span>;<br>            <span style="color: #0000ff;">string</span> fileName = name + <span style="color: #800000;">“</span><span style="color: #800000;">.dll</span><span style="color: #800000;">“</span>;<br>            var assemblyName = <span style="color: #0000ff;">new</span> AssemblyName(name);<br>            var assemblyBuilder = AppDomain.CurrentDomain.DefineDynamicAssembly(assemblyName,<br>                                                                                AssemblyBuilderAccess.RunAndSave);<br>            var moduleBuilder = assemblyBuilder.DefineDynamicModule(name, fileName);</pre><br></div>

<p>接下来是定义类，要点是修饰参数要一致，基类是MulticastDelegate</p>
<div class="cnblogs_code"><br><pre> <span style="color: #008000;">//</span><span style="color: #008000;">public auto ansi sealed</span><span style="color: #008000;"><br></span>            var delegateBuilder = moduleBuilder.DefineType(<span style="color: #800000;">“</span><span style="color: #800000;">MyDelegate</span><span style="color: #800000;">“</span>,<br>                                     TypeAttributes.Public | TypeAttributes.AutoLayout | TypeAttributes.AnsiClass |<br>                                     TypeAttributes.Sealed, typeof(MulticastDelegate));</pre><br></div>

<p>在设置构造函数，修饰参数也要一致，函数参数为object和IntPtr</p>
<p>最重要的是最后一句设置方法实现标志为runtime</p>
<div class="cnblogs_code"><br><pre>  <span style="color: #008000;">//</span><span style="color: #008000;">            .method public hidebysig specialname rtspecialname </span><span style="color: #008000;"><br></span>            <span style="color: #008000;">//</span><span style="color: #008000;">        instance void  .ctor(object ‘object’,</span><span style="color: #008000;"><br></span>            <span style="color: #008000;">//</span><span style="color: #008000;">                             native int ‘method’) runtime managed</span><span style="color: #008000;"><br></span>            <span style="color: #008000;">//</span><span style="color: #008000;">{</span><span style="color: #008000;"><br></span>            <span style="color: #008000;">//</span><span style="color: #008000;">} // end of method MyDelegate::.ctor</span><span style="color: #008000;"><br></span><br>            var constructorBuilder = delegateBuilder.DefineConstructor(<br>                MethodAttributes.Public | MethodAttributes.HideBySig | MethodAttributes.SpecialName |<br>                MethodAttributes.RTSpecialName,<br>                CallingConventions.Standard, <span style="color: #0000ff;">new</span>[] { typeof(<span style="color: #0000ff;">object</span>), typeof(IntPtr) }<br>                );<br>            constructorBuilder.SetImplementationFlags(MethodImplAttributes.Runtime);</pre><br></div>

<p>然后是定义方法Invoke，这里定义的返回值和参数都是string 可以根据需要调整。</p>
<p>同样修饰要一致，最后也要设置方法实现标志为Runtime</p>
<div class="cnblogs_code"><br><pre> <span style="color: #008000;">//</span><span style="color: #008000;">            .method public hidebysig newslot virtual </span><span style="color: #008000;"><br></span>            <span style="color: #008000;">//</span><span style="color: #008000;">        instance string  Invoke(string message) runtime managed</span><span style="color: #008000;"><br></span>            <span style="color: #008000;">//</span><span style="color: #008000;">{</span><span style="color: #008000;"><br></span>            <span style="color: #008000;">//</span><span style="color: #008000;">} // end of method MyDelegate::Invoke</span><span style="color: #008000;"><br></span>            var resultType = typeof(<span style="color: #0000ff;">string</span>);<br>            var paramTypes = <span style="color: #0000ff;">new</span>[] { typeof(<span style="color: #0000ff;">string</span>) };<br>            var methodBuilder = delegateBuilder.DefineMethod(<span style="color: #800000;">“</span><span style="color: #800000;">Invoke</span><span style="color: #800000;">“</span>,<br>                                          MethodAttributes.Public | MethodAttributes.HideBySig | MethodAttributes.NewSlot |<br>                                          MethodAttributes.Virtual,<br>                                          CallingConventions.Standard, resultType, paramTypes);<br>            methodBuilder.SetImplementationFlags(MethodImplAttributes.Runtime);</pre><br></div>

<p>&nbsp;</p>
<p>最后创建类型，好了，定义完成了。</p>
<div class="cnblogs_code"><br><pre>var delegateType = delegateBuilder.CreateType();</pre><br></div>

<p>接下来就需要调用测试一下了。</p>
<p>注意不能用Activator.CreateInstance()来初始化代理而是Delegate.CreateDelegate。</p>
<div class="cnblogs_code"><br><pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> MyClass<br>    {<br><br>        <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">string</span> MyMethod(<span style="color: #0000ff;">string</span> message)<br>        {<br>            Console.WriteLine(message);<br>            return message;<br>        }<br><br>    }</pre><br></div>

<p>&nbsp;</p>
<p>调用</p>
<div class="cnblogs_code"><br><pre> MyClass myClass = <span style="color: #0000ff;">new</span> MyClass();<br>            var myDelegate = Delegate.CreateDelegate(delegateType, myClass, <span style="color: #800000;">“</span><span style="color: #800000;">MyMethod</span><span style="color: #800000;">“</span>);<br>            myDelegate.DynamicInvoke(<span style="color: #800000;">“</span><span style="color: #800000;">Hello World!</span><span style="color: #800000;">“</span>);</pre><br></div>

<p>结果 Hello World!</p>
<p>OK 成功了。</p>
<p>&nbsp;</p>

    
  </div>
  <footer>
    
      
  
  <div class="categories">
    <a href="/categories/未分类/">未分类</a>
  </div>

      
    
    <div class="clearfix"></div>
  </footer>
</article>

</div>
  </div>
  <div class="widget-wrapper">
    <aside id="sidebar">
  
  
    
      
      

<div class="widget tag first">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/未分类/">未分类</a><small>67</small></li>
  
  </ul>
</div>

    
      
      
    
      
      
    
      
      

<div class="widget recent-posts">
  <h3 class="title">最近的文章</h3>
  <ul class="entry">
    
      <li>
        <a href="/2014/03/19/hello-world/">Hello World</a>
      </li>
    
      <li>
        <a href="/2012/11/02/windows-phone-toolkit-for-wp8-已经出了/">Windows Phone Toolkit for WP8 已经出了</a>
      </li>
    
      <li>
        <a href="/2012/06/17/代码分享-scrollviewerlistener-获取scrollviewer的位置改变/">代码分享 ScrollViewerListener 获取ScrollViewer的位置改变</a>
      </li>
    
      <li>
        <a href="/2012/04/18/经验-c手动同步的滥用实例/">经验 C#手动同步的滥用实例</a>
      </li>
    
      <li>
        <a href="/2012/04/06/wp7技巧-扩展【共享-】按钮/">WP7技巧 扩展【共享...】按钮</a>
      </li>
    
  </ul>
</div>

    
      
      

<div class="widget blogroll">
  <h3 class="title">友情链接</h3>
  <ul class="entry">
  
    
    <li><a href="http://heroicyang.com/" target="_blank">Heroic Yang&#39;s Blog</a></li>
  
  </ul>
</div>

    
  
</aside>
<div class="clearfix"></div>
  </div>
  <footer id="footer"><div class="copyright">
  
  &copy; 2014 <a href="/">kiminozo</a>
  
</div>
<div class="theme-copyright">
  Theme by <a href="https://github.com/orderedlist" target="_blank">orderedlist</a>
   | 
  Redesign by <a href="http://heroicyang.com/" target="_blank">Heroic Yang</a>
</div>
<div class="clearfix"></div></footer>
  <script src="/js/scale.fix.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
  (function($){
    $('.fancybox').fancybox();
  })(jQuery);
</script>

</body>
</html>